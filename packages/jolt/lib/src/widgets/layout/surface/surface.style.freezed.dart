// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'surface.style.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SurfaceStyle {
  /// The width of the surface
  double? get width => throw _privateConstructorUsedError;

  /// The height of the surface
  double? get height => throw _privateConstructorUsedError;
  BoxConstraints? get constraints => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get margin => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get padding => throw _privateConstructorUsedError;
  Clip? get clipBehavior => throw _privateConstructorUsedError;
  Color? get color => throw _privateConstructorUsedError;
  Color? get borderColor => throw _privateConstructorUsedError;
  DecorationImage? get image => throw _privateConstructorUsedError;
  Border? get border => throw _privateConstructorUsedError;
  BorderRadiusGeometry? get borderRadius => throw _privateConstructorUsedError;
  List<BoxShadow>? get boxShadow => throw _privateConstructorUsedError;
  Gradient? get gradient => throw _privateConstructorUsedError;
  BlendMode? get backgroundBlendMode => throw _privateConstructorUsedError;
  BoxShape? get shape => throw _privateConstructorUsedError;
  Duration? get animationDuration => throw _privateConstructorUsedError;

  /// Whether the surface should have a splash effect, defaults to false
  bool? get splash => throw _privateConstructorUsedError;

  /// Whether the surface should resolve the background color
  /// defaults to true
  ///
  /// For example you might want a transparent surface with no hover effect.
  bool? get resolveBackgroundColor => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SurfaceStyleCopyWith<SurfaceStyle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SurfaceStyleCopyWith<$Res> {
  factory $SurfaceStyleCopyWith(
          SurfaceStyle value, $Res Function(SurfaceStyle) then) =
      _$SurfaceStyleCopyWithImpl<$Res, SurfaceStyle>;
  @useResult
  $Res call(
      {double? width,
      double? height,
      BoxConstraints? constraints,
      EdgeInsetsGeometry? margin,
      EdgeInsetsGeometry? padding,
      Clip? clipBehavior,
      Color? color,
      Color? borderColor,
      DecorationImage? image,
      Border? border,
      BorderRadiusGeometry? borderRadius,
      List<BoxShadow>? boxShadow,
      Gradient? gradient,
      BlendMode? backgroundBlendMode,
      BoxShape? shape,
      Duration? animationDuration,
      bool? splash,
      bool? resolveBackgroundColor});
}

/// @nodoc
class _$SurfaceStyleCopyWithImpl<$Res, $Val extends SurfaceStyle>
    implements $SurfaceStyleCopyWith<$Res> {
  _$SurfaceStyleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? constraints = freezed,
    Object? margin = freezed,
    Object? padding = freezed,
    Object? clipBehavior = freezed,
    Object? color = freezed,
    Object? borderColor = freezed,
    Object? image = freezed,
    Object? border = freezed,
    Object? borderRadius = freezed,
    Object? boxShadow = freezed,
    Object? gradient = freezed,
    Object? backgroundBlendMode = freezed,
    Object? shape = freezed,
    Object? animationDuration = freezed,
    Object? splash = freezed,
    Object? resolveBackgroundColor = freezed,
  }) {
    return _then(_value.copyWith(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      constraints: freezed == constraints
          ? _value.constraints
          : constraints // ignore: cast_nullable_to_non_nullable
              as BoxConstraints?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsetsGeometry?,
      padding: freezed == padding
          ? _value.padding
          : padding // ignore: cast_nullable_to_non_nullable
              as EdgeInsetsGeometry?,
      clipBehavior: freezed == clipBehavior
          ? _value.clipBehavior
          : clipBehavior // ignore: cast_nullable_to_non_nullable
              as Clip?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      borderColor: freezed == borderColor
          ? _value.borderColor
          : borderColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as DecorationImage?,
      border: freezed == border
          ? _value.border
          : border // ignore: cast_nullable_to_non_nullable
              as Border?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadiusGeometry?,
      boxShadow: freezed == boxShadow
          ? _value.boxShadow
          : boxShadow // ignore: cast_nullable_to_non_nullable
              as List<BoxShadow>?,
      gradient: freezed == gradient
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Gradient?,
      backgroundBlendMode: freezed == backgroundBlendMode
          ? _value.backgroundBlendMode
          : backgroundBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      animationDuration: freezed == animationDuration
          ? _value.animationDuration
          : animationDuration // ignore: cast_nullable_to_non_nullable
              as Duration?,
      splash: freezed == splash
          ? _value.splash
          : splash // ignore: cast_nullable_to_non_nullable
              as bool?,
      resolveBackgroundColor: freezed == resolveBackgroundColor
          ? _value.resolveBackgroundColor
          : resolveBackgroundColor // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SurfaceStyleImplCopyWith<$Res>
    implements $SurfaceStyleCopyWith<$Res> {
  factory _$$SurfaceStyleImplCopyWith(
          _$SurfaceStyleImpl value, $Res Function(_$SurfaceStyleImpl) then) =
      __$$SurfaceStyleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? width,
      double? height,
      BoxConstraints? constraints,
      EdgeInsetsGeometry? margin,
      EdgeInsetsGeometry? padding,
      Clip? clipBehavior,
      Color? color,
      Color? borderColor,
      DecorationImage? image,
      Border? border,
      BorderRadiusGeometry? borderRadius,
      List<BoxShadow>? boxShadow,
      Gradient? gradient,
      BlendMode? backgroundBlendMode,
      BoxShape? shape,
      Duration? animationDuration,
      bool? splash,
      bool? resolveBackgroundColor});
}

/// @nodoc
class __$$SurfaceStyleImplCopyWithImpl<$Res>
    extends _$SurfaceStyleCopyWithImpl<$Res, _$SurfaceStyleImpl>
    implements _$$SurfaceStyleImplCopyWith<$Res> {
  __$$SurfaceStyleImplCopyWithImpl(
      _$SurfaceStyleImpl _value, $Res Function(_$SurfaceStyleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? constraints = freezed,
    Object? margin = freezed,
    Object? padding = freezed,
    Object? clipBehavior = freezed,
    Object? color = freezed,
    Object? borderColor = freezed,
    Object? image = freezed,
    Object? border = freezed,
    Object? borderRadius = freezed,
    Object? boxShadow = freezed,
    Object? gradient = freezed,
    Object? backgroundBlendMode = freezed,
    Object? shape = freezed,
    Object? animationDuration = freezed,
    Object? splash = freezed,
    Object? resolveBackgroundColor = freezed,
  }) {
    return _then(_$SurfaceStyleImpl(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      constraints: freezed == constraints
          ? _value.constraints
          : constraints // ignore: cast_nullable_to_non_nullable
              as BoxConstraints?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsetsGeometry?,
      padding: freezed == padding
          ? _value.padding
          : padding // ignore: cast_nullable_to_non_nullable
              as EdgeInsetsGeometry?,
      clipBehavior: freezed == clipBehavior
          ? _value.clipBehavior
          : clipBehavior // ignore: cast_nullable_to_non_nullable
              as Clip?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      borderColor: freezed == borderColor
          ? _value.borderColor
          : borderColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as DecorationImage?,
      border: freezed == border
          ? _value.border
          : border // ignore: cast_nullable_to_non_nullable
              as Border?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadiusGeometry?,
      boxShadow: freezed == boxShadow
          ? _value._boxShadow
          : boxShadow // ignore: cast_nullable_to_non_nullable
              as List<BoxShadow>?,
      gradient: freezed == gradient
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Gradient?,
      backgroundBlendMode: freezed == backgroundBlendMode
          ? _value.backgroundBlendMode
          : backgroundBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      animationDuration: freezed == animationDuration
          ? _value.animationDuration
          : animationDuration // ignore: cast_nullable_to_non_nullable
              as Duration?,
      splash: freezed == splash
          ? _value.splash
          : splash // ignore: cast_nullable_to_non_nullable
              as bool?,
      resolveBackgroundColor: freezed == resolveBackgroundColor
          ? _value.resolveBackgroundColor
          : resolveBackgroundColor // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$SurfaceStyleImpl extends _SurfaceStyle {
  const _$SurfaceStyleImpl(
      {this.width,
      this.height,
      this.constraints,
      this.margin,
      this.padding,
      this.clipBehavior,
      this.color,
      this.borderColor,
      this.image,
      this.border,
      this.borderRadius,
      final List<BoxShadow>? boxShadow,
      this.gradient,
      this.backgroundBlendMode,
      this.shape,
      this.animationDuration,
      this.splash,
      this.resolveBackgroundColor})
      : _boxShadow = boxShadow,
        super._();

  /// The width of the surface
  @override
  final double? width;

  /// The height of the surface
  @override
  final double? height;
  @override
  final BoxConstraints? constraints;
  @override
  final EdgeInsetsGeometry? margin;
  @override
  final EdgeInsetsGeometry? padding;
  @override
  final Clip? clipBehavior;
  @override
  final Color? color;
  @override
  final Color? borderColor;
  @override
  final DecorationImage? image;
  @override
  final Border? border;
  @override
  final BorderRadiusGeometry? borderRadius;
  final List<BoxShadow>? _boxShadow;
  @override
  List<BoxShadow>? get boxShadow {
    final value = _boxShadow;
    if (value == null) return null;
    if (_boxShadow is EqualUnmodifiableListView) return _boxShadow;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Gradient? gradient;
  @override
  final BlendMode? backgroundBlendMode;
  @override
  final BoxShape? shape;
  @override
  final Duration? animationDuration;

  /// Whether the surface should have a splash effect, defaults to false
  @override
  final bool? splash;

  /// Whether the surface should resolve the background color
  /// defaults to true
  ///
  /// For example you might want a transparent surface with no hover effect.
  @override
  final bool? resolveBackgroundColor;

  @override
  String toString() {
    return 'SurfaceStyle(width: $width, height: $height, constraints: $constraints, margin: $margin, padding: $padding, clipBehavior: $clipBehavior, color: $color, borderColor: $borderColor, image: $image, border: $border, borderRadius: $borderRadius, boxShadow: $boxShadow, gradient: $gradient, backgroundBlendMode: $backgroundBlendMode, shape: $shape, animationDuration: $animationDuration, splash: $splash, resolveBackgroundColor: $resolveBackgroundColor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SurfaceStyleImpl &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.constraints, constraints) ||
                other.constraints == constraints) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.padding, padding) || other.padding == padding) &&
            (identical(other.clipBehavior, clipBehavior) ||
                other.clipBehavior == clipBehavior) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.borderColor, borderColor) ||
                other.borderColor == borderColor) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.border, border) || other.border == border) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            const DeepCollectionEquality()
                .equals(other._boxShadow, _boxShadow) &&
            (identical(other.gradient, gradient) ||
                other.gradient == gradient) &&
            (identical(other.backgroundBlendMode, backgroundBlendMode) ||
                other.backgroundBlendMode == backgroundBlendMode) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            (identical(other.animationDuration, animationDuration) ||
                other.animationDuration == animationDuration) &&
            (identical(other.splash, splash) || other.splash == splash) &&
            (identical(other.resolveBackgroundColor, resolveBackgroundColor) ||
                other.resolveBackgroundColor == resolveBackgroundColor));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      width,
      height,
      constraints,
      margin,
      padding,
      clipBehavior,
      color,
      borderColor,
      image,
      border,
      borderRadius,
      const DeepCollectionEquality().hash(_boxShadow),
      gradient,
      backgroundBlendMode,
      shape,
      animationDuration,
      splash,
      resolveBackgroundColor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SurfaceStyleImplCopyWith<_$SurfaceStyleImpl> get copyWith =>
      __$$SurfaceStyleImplCopyWithImpl<_$SurfaceStyleImpl>(this, _$identity);
}

abstract class _SurfaceStyle extends SurfaceStyle {
  const factory _SurfaceStyle(
      {final double? width,
      final double? height,
      final BoxConstraints? constraints,
      final EdgeInsetsGeometry? margin,
      final EdgeInsetsGeometry? padding,
      final Clip? clipBehavior,
      final Color? color,
      final Color? borderColor,
      final DecorationImage? image,
      final Border? border,
      final BorderRadiusGeometry? borderRadius,
      final List<BoxShadow>? boxShadow,
      final Gradient? gradient,
      final BlendMode? backgroundBlendMode,
      final BoxShape? shape,
      final Duration? animationDuration,
      final bool? splash,
      final bool? resolveBackgroundColor}) = _$SurfaceStyleImpl;
  const _SurfaceStyle._() : super._();

  @override

  /// The width of the surface
  double? get width;
  @override

  /// The height of the surface
  double? get height;
  @override
  BoxConstraints? get constraints;
  @override
  EdgeInsetsGeometry? get margin;
  @override
  EdgeInsetsGeometry? get padding;
  @override
  Clip? get clipBehavior;
  @override
  Color? get color;
  @override
  Color? get borderColor;
  @override
  DecorationImage? get image;
  @override
  Border? get border;
  @override
  BorderRadiusGeometry? get borderRadius;
  @override
  List<BoxShadow>? get boxShadow;
  @override
  Gradient? get gradient;
  @override
  BlendMode? get backgroundBlendMode;
  @override
  BoxShape? get shape;
  @override
  Duration? get animationDuration;
  @override

  /// Whether the surface should have a splash effect, defaults to false
  bool? get splash;
  @override

  /// Whether the surface should resolve the background color
  /// defaults to true
  ///
  /// For example you might want a transparent surface with no hover effect.
  bool? get resolveBackgroundColor;
  @override
  @JsonKey(ignore: true)
  _$$SurfaceStyleImplCopyWith<_$SurfaceStyleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
